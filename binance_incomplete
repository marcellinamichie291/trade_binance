#!/usr/bin/env python
# coding: utf-8

# In[1]:


import math
from pandas_datareader import data as pdr
import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from keras.models import Sequential
from keras.layers import Dense, LSTM
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
from numpy import loadtxt
from tensorflow.keras.models import load_model
import warnings
import pandas as pd
warnings.filterwarnings("ignore", category=np.VisibleDeprecationWarning)
from datetime import datetime, timedelta
import tensorflow as tf
import numpy as np
import pandas as pd
from binance.client import Client
import time
import os


# In[2]:


class ML():
    scaler = MinMaxScaler(feature_range=(0,1))
    def __init__(self, stock_data, model_path):
        self.stock_data = stock_data
        self.model = tf.keras.models.load_model(model_path)
        
  
    def pred_values(self):
        a4 = self.stock_data['Close'].values.reshape(-1,1)
        last_60_dayss = a4[-60:]
        last_60_dayss = self.scaler.fit_transform(last_60_dayss)
        next_test = []
        next_test.append(last_60_dayss)
        next_test = np.array(next_test)
        next_test = np.reshape(next_test, (next_test.shape[0], next_test.shape[1], 1))
        price = self.model.predict(next_test)
        pred = self.scaler.inverse_transform(price)
        return float(pred)


# In[3]:


def login():
    api_key = '4314GINvPNROw7IFtu4rO24z3jY5DnAXL8UMyko2eNw0YXT9r6DuAZtlDgqnlstt'
    api_secret = 'DZti3rtFGNkvuY58NEn1uqKFYoyjofL4LYlzoPUAEEI7tqAVCaHimvT8grpfTMKp'
    client = Client(api_key, api_secret, testnet=False)
    return client


# In[4]:


def gethourlydata(symbol, interval, lookback):
    frame = pd.DataFrame(client.get_historical_klines(symbol, interval, lookback ))
    frame = frame.iloc[:, :6]
    frame.columns = ['Time', 'Open', 'High', 'Low', 'Close', 'Volume']
    frame = frame.set_index('Time')
    frame.index = pd.to_datetime(frame.index, unit = 'ms')
    frame = frame.astype(float)
    return frame


# In[5]:


path = '/home/icarus/Project/btc.hdf5' 


# In[6]:


def column(df):    
    df['Predictions'] = np.NaN
    for i in range(len(df.values) - 1,len(df.values)):
        df["Predictions"][i] = ML(df.iloc[:i,:], path).pred_values()
    return df

def current_price(pair = 'BTCUSDT'):
    time.sleep(2)
    price = client.get_ticker(symbol = pair)
    ask_price = float(price['askPrice'])
    bid_price = float(price['bidPrice'])
    return ask_price, bid_price
    


# In[7]:


class Signals():
    def __init__(self, df):
        self.df = df              
    def decide(self):
        self.df['Buy'] = np.where(self.df['Predictions'] > self.df['Close'] , 1, 0 )
        self.df['Sell'] = np.where(self.df['Predictions'] < self.df['Close'] , -1, 0 )
        


# In[31]:


def strategy(pair, qty, open_positions = False):
    time.sleep(60)
    df = gethourlydata('BTCUSDT', '1h', '3days')
    df = column(df)
    inst= Signals(df)
    inst.decide()
    print(f'current Close is ' + str(df.Close.iloc[-1]))
    print(f'current Predicted is ' + str(df.Predictions.iloc[-1]))
    price = client.get_ticker(symbol = pair)
    ask_price = float(price['askPrice'])
    bid_price = float(price['bidPrice'])
    target = float(df.Predictions.iloc[-1])
    per_buy = qty * ((target-ask_price)/ask_price * 100) * 100
    per_sell = qty * ((target-bid_price)/bid_price * 100) * 100
    print('buy_change is '+ str(per_buy))
    print('sell_change is ' + str(per_sell))
    
    if per_buy >= 0.15 and df.Buy.iloc[-1]:
        order = client.futures_create_order(symbol=pair, side ='BUY', type = 'MARKET', quantity = qty)
        print(order)
        buyprice = ask_price
        open_position = True
        
        while open_position:
                time.sleep(5)
                print(f'current Mark price is ' + str(current_price()[1]))
                print(f'current Target ' + str(target))
                print(f'current Stop Loss ' + str(buyprice*0.9985))
                
                if current_price()[1] >= target or current_price()[1] <= buyprice*0.9985:
                    order = client.futures_create_order(symbol=pair, side ='SELL', type = 'MARKET', quantity = qty)
                    print(order)
                    time.sleep(600)
                    break

                    
    if per_sell <= -0.15 and df.Sell.iloc[-1]:
        order = client.futures_create_order(symbol=pair, side ='SELL', type = 'MARKET', quantity = qty)
        print(order)
        sellprice = bid_price
        open_position = True
    
        while open_position:
                    time.sleep(5)
                    print(f'current Mark price is ' + str(current_price()[0]))
                    print(f'current Target ' + str(target))
                    print(f'current Stop Loss ' + str(sellprice*1.0012))
                    
                    if current_price()[0] >= sellprice*1.0012 or current_price()[0] <= target:
                        order = client.futures_create_order(symbol=pair, side ='BUY', type = 'MARKET', quantity = qty)
                        print(order)
                        time.sleep(600)
                        break


              
    


# In[ ]:


while True:
    try:
        client = login()
        strategy('BTCUSDT', 0.009)
        
    except:
        print('Trying again in 5 mins')
        time.sleep(300)
        continue
            


# In[ ]:


def check_ping():
    host = '8.8.8.8'
    response = os.system("ping -c 1 " + host)
    if response == 0:
        pingstatus = 0
    else:
        pingstatus = 1
    return pingstatus


# In[ ]:


def strategy(pair, qty, open_positions = False):
    time.sleep(60)
    df = gethourlydata('BTCUSDT', '1h', '3days')
    df = column(df)
    inst= Signals(df)
    inst.decide()
    print(f'current Close is ' + str(df.Close.iloc[-1]))
    print(f'current Predicted is ' + str(df.Predictions.iloc[-1]))
    price = client.get_ticker(symbol = pair)
    ask_price = float(price['askPrice'])
    bid_price = float(price['bidPrice'])
    target = float(df.Predictions.iloc[-1])
    per_buy = qty * ((target-ask_price)/ask_price * 100) * 100
    per_sell = qty * ((target-bid_price)/bid_price * 100) * 100
    print('buy_change is '+ str(per_buy))
    print('sell_change is ' + str(per_sell))
    
    if per_buy >= 0.15 and df.Buy.iloc[-1]:
        order = client.futures_create_order(symbol=pair, side ='BUY', type = 'MARKET', quantity = qty)
        print(order)
        buyprice = ask_price
        open_position = True
        
        while open_position:
                time.sleep(5)
                tp = target
                sl = buyprice*0.9985
                profit = client.futures_create_order(symbol=pair, positionSide = 'LONG', type ='TAKE_PROFIT_MARKET', stopPrice = tp, side ='SELL', timeInForce = "GTC", workingType='MARK_PRICE', priceProtect= True, quantity=qty)
                loss = client.futures_create_order(symbol=pair, positionSide = 'LONG', type ='STOP_MARKET', stopPrice = sl, side ='SELL', timeInForce = "GTC", workingType='MARK_PRICE', priceProtect= True, quantity=qty)
                print(loss)
                print(profit)
                break
                    
    if per_sell <= -0.15 and df.Sell.iloc[-1]:
        order = client.futures_create_order(symbol=pair, side ='SELL', type = 'MARKET', quantity = qty)
        print(order)
        sellprice = bid_price
        open_position = True
    
        while open_position:
                    time.sleep(5)
                    tp = target
                    sl = sellprice*1.0012
                    profit = client.futures_create_order(symbol=pair, positionSide = 'SHORT', type ='TAKE_PROFIT_MARKET', stopPrice = tp, side ='BUY', timeInForce = "GTC", workingType='MARK_PRICE', priceProtect= True, quantity=qty)
                    loss = client.futures_create_order(symbol=pair, positionSide = 'SHORT', type ='STOP_MARKET', stopPrice = sl, side ='BUY', timeInForce = "GTC", workingType='MARK_PRICE', priceProtect= True, quantity=qty)
                    print(profit)
                    print(loss)
                    break

              
    
